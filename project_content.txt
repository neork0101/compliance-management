Project Structure:


Code Files and Resources:



Java Files from src/main/java:


// File: src/main/java/com/in/auth/controller/AuthController.java

package com.in.auth.controller;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.in.security.util.AppConstants;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse; // Add this
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.media.Content; // Add this
import io.swagger.v3.oas.annotations.media.Schema;  // Add this
import io.swagger.v3.oas.annotations.tags.Tag;

import com.in.auth.dto.ErrorDetails;
//import com.in.compliance.dto.ResponseDto;
import com.in.auth.dto.ResponseDto;
import com.in.auth.payload.request.LoginRequest;
import com.in.auth.payload.request.SignupRequest;
import com.in.auth.payload.response.MessageResponse;
import com.in.auth.payload.response.UserInfoResponse;
import com.in.auth.repository.RoleRepository;
import com.in.auth.repository.UserRepository;
import com.in.auth.service.UserDetailsImpl;

//import com.in.compliance.models.Role;
//import com.in.compliance.models.User;
//import com.in.compliance.payload.request.LoginRequest;
//import com.in.compliance.payload.request.SignupRequest;
//import com.in.compliance.payload.response.MessageResponse;
//import com.in.compliance.payload.response.UserInfoResponse;
//import com.in.compliance.repository.RoleRepository;
//import com.in.compliance.repository.UserRepository;
//import com.in.compliance.service.UserDetailsImpl;
import com.in.security.jwt.JwtUtils;
import com.in.security.models.ERole;
import com.in.security.models.Role;
import com.in.security.models.User;

import jakarta.validation.Valid;

@CrossOrigin(origins = "*", maxAge = 3600)
@RestController
@RequestMapping("/api/auth")
@Tag(name = "Authentication Controller", description = "Endpoints for user authentication and registration")
public class AuthController {

	private static final Logger LOG = LoggerFactory.getLogger(AuthController.class);

	@Autowired(required = true)
	private AuthenticationManager authenticationManager;

	@Autowired(required = true)
	private UserRepository userRepository;

	@Autowired(required = true)
	private RoleRepository roleRepository;

	@Autowired(required = true)
	private PasswordEncoder encoder;

	@Autowired(required = true)
	private JwtUtils jwtUtils;

	@PostMapping("/signin")
    @Operation(summary = "Authenticate user and return JWT token",
               description = "Authenticates the user with the provided credentials and returns a JWT token in the Authorization header.")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Successfully authenticated",
                     content = @Content(mediaType = "application/json",
                                        schema = @Schema(implementation = UserInfoResponse.class))),
        @ApiResponse(responseCode = "401", description = "Invalid credentials",
                     content = @Content(mediaType = "application/json",
                                        schema = @Schema(implementation = ErrorDetails.class)))
    })
	public ResponseEntity<ResponseDto> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {

		LOG.info("Start Method:authenticateUser");
		Authentication authentication = authenticationManager.authenticate(
				new UsernamePasswordAuthenticationToken(loginRequest.getUsername(), loginRequest.getPassword()));

		SecurityContextHolder.getContext().setAuthentication(authentication);

		UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();

		// for cookie approach
		// ResponseCookie jwtCookie = jwtUtils.generateJwtCookie(userDetails);
		String jwtToken = jwtUtils.generateToken(userDetails);

		List<String> roles = userDetails.getAuthorities().stream().map(item -> item.getAuthority()).toList();

		// USed for cookie approach
		/*
		 * return ResponseEntity.ok().header(HttpHeaders.SET_COOKIE,
		 * jwtCookie.toString()) .body(new UserInfoResponse(userDetails.getId(),
		 * userDetails.getUsername(), userDetails.getEmail(), roles));
		 */

		LOG.info("End Method:authenticateUser");

		return ResponseEntity.ok().header("Authorization", jwtToken).body(
				new UserInfoResponse(userDetails.getId(), userDetails.getUsername(), userDetails.getEmail(), roles));
	}

	@PostMapping("/signup")
    @Operation(summary = "Register a new user",
               description = "Creates a new user account with the provided details.")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "User registered successfully",
                     content = @Content(mediaType = "application/json",
                                        schema = @Schema(implementation = MessageResponse.class))),
        @ApiResponse(responseCode = "400", description = "Bad request, invalid input",
                     content = @Content(mediaType = "application/json",
                                        schema = @Schema(implementation = ErrorDetails.class)))
    })
	public ResponseEntity<ResponseDto> registerUser(@Valid @RequestBody SignupRequest signUpRequest) {

		LOG.info("Start Method:registerUser");
		if (userRepository.existsByUsername(signUpRequest.getUsername()).booleanValue()) {
			LOG.info("Method:registerUser -Error: Username is already taken! ");
			return ResponseEntity.badRequest().body(new MessageResponse("Error: Username is already taken! "+signUpRequest.getUsername()));
		}

		if (userRepository.existsByEmail(signUpRequest.getEmail())) {
			LOG.info("Method:registerUser -Error: Email is already taken! "+signUpRequest.getEmail());
			return ResponseEntity.badRequest().body(new MessageResponse("Error: Email is already in use!"));
		}

		// Create the new user's account
		LOG.info("Method:registerUser - Create the new user's account ");
		User user = new User(signUpRequest.getUsername(), signUpRequest.getEmail(),
				encoder.encode(signUpRequest.getPassword()));

		Set<String> strRoles = signUpRequest.getRoles();
		Set<Role> roles = new HashSet<>();

		if (strRoles == null) {
			Role userRole = roleRepository.findByName(ERole.ROLE_USER)
					.orElseThrow(() -> new RuntimeException(AppConstants.ROLE_NOTFOUND));
			roles.add(userRole);
		} else {
			strRoles.forEach(role -> {
				switch (role) {
				case "admin":
					Role adminRole = roleRepository.findByName(ERole.ROLE_ADMIN)
							.orElseThrow(() -> new RuntimeException(AppConstants.ROLE_NOTFOUND));
					roles.add(adminRole);

					break;
				case "mod":
					Role modRole = roleRepository.findByName(ERole.ROLE_MODERATOR)
							.orElseThrow(() -> new RuntimeException(AppConstants.ROLE_NOTFOUND));
					roles.add(modRole);

					break;
				default:
					Role userRole = roleRepository.findByName(ERole.ROLE_USER)
							.orElseThrow(() -> new RuntimeException(AppConstants.ROLE_NOTFOUND));
					roles.add(userRole);
				}
			});
		}

		user.setRoles(roles);
		userRepository.save(user);
		LOG.info("Method:registerUser -User registered successfully!");
		return ResponseEntity.ok(new MessageResponse("User registered successfully!"));
	}
}

// File: src/main/java/com/in/auth/dto/ErrorDetails.java

package com.in.auth.dto;

import io.swagger.v3.oas.annotations.media.Schema;

public class ErrorDetails implements ResponseDto{
    @Schema(description = "HTTP status code", example = "400")
    private int statusCode;

    @Schema(description = "Error message", example = "Invalid credentials")
    private String message;

    @Schema(description = "Detailed error description", example = "Username or password is incorrect")
    private String details;

    public ErrorDetails(int statusCode, String message, String details) {
        this.statusCode = statusCode;
        this.message = message;
        this.details = details;
    }

    // Getters and setters
    public int getStatusCode() {
        return statusCode;
    }

    public void setStatusCode(int statusCode) {
        this.statusCode = statusCode;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public String getDetails() {
        return details;
    }

    public void setDetails(String details) {
        this.details = details;
    }
}

// File: src/main/java/com/in/auth/dto/ResponseDto.java

package com.in.auth.dto;

public interface ResponseDto {

}

// File: src/main/java/com/in/auth/payload/request/LoginRequest.java

package com.in.auth.payload.request;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;

public class LoginRequest {
  @NotBlank
  @Schema(description = "User's username", example = "john_doe")
  private String username;

  @NotBlank
  @Schema(description = "User's password", example = "securePassword123")
  private String password;

  public LoginRequest(String username, String password) {
	  this.username=username;
	  this.password=password;
  }

public String getUsername() {
    return username;
  }

  public void setUsername(String username) {
    this.username = username;
  }

  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }
}

// File: src/main/java/com/in/auth/payload/request/SignupRequest.java

package com.in.auth.payload.request;

import java.util.HashSet;
import java.util.Set;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class SignupRequest {
  @NotBlank
  @Size(min = 3, max = 20)
  @Schema(description = "Desired username", example = "new_user")
  private String username;

  @NotBlank
  @Size(max = 50)
  @Email
  @Schema(description = "User's email address", example = "new_user@example.com")
  private String email;
  
  @Schema(description = "Roles to assign to the user", example = "[\"user\", \"admin\"]")
  private Set<String> roles;

  @NotBlank
  @Size(min = 6, max = 40)
  @Schema(description = "Desired password", example = "StrongPass!123")
  private String password;

  public SignupRequest(String username, String email, HashSet roles) {
	this.username=username;
	this.email=email;
	this.roles=roles;
}

public String getUsername() {
    return username;
  }

  public void setUsername(String username) {
    this.username = username;
  }

  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }

  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  public Set<String> getRoles() {
    return this.roles;
  }

  public void setRole(Set<String> roles) {
    this.roles = roles;
  }
}

// File: src/main/java/com/in/auth/payload/response/MessageResponse.java

package com.in.auth.payload.response;

import com.in.auth.dto.ResponseDto;

import io.swagger.v3.oas.annotations.media.Schema;

public class MessageResponse implements ResponseDto{
    @Schema(description = "Response message", example = "User registered successfully!")
    private String message;

  public MessageResponse(String message) {
    this.message = message;
  }

  public String getMessage() {
    return message;
  }

  public void setMessage(String message) {
    this.message = message;
  }
}

// File: src/main/java/com/in/auth/payload/response/UserInfoResponse.java

package com.in.auth.payload.response;

import java.util.List;

import com.in.auth.dto.ResponseDto;

import io.swagger.v3.oas.annotations.media.Schema;

public class UserInfoResponse implements ResponseDto{
    @Schema(description = "Unique user identifier", example = "6123456789abcdef01234567")
    private String id;

    @Schema(description = "User's username", example = "john_doe")
    private String username;

    @Schema(description = "User's email address", example = "john_doe@example.com")
    private String email;

    @Schema(description = "List of roles assigned to the user", example = "[\"ROLE_USER\", \"ROLE_ADMIN\"]")
    private List<String> roles;

  public UserInfoResponse(String id, String username, String email, List<String> roles) {
    this.id = id;
    this.username = username;
    this.email = email;
    this.roles = roles;
  }

  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }

  public String getUsername() {
    return username;
  }

  public void setUsername(String username) {
    this.username = username;
  }

  public List<String> getRoles() {
    return roles;
  }
}

// File: src/main/java/com/in/auth/repository/RoleRepository.java

package com.in.auth.repository;

import java.util.Optional;

import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;

import com.in.security.models.ERole;
import com.in.security.models.Role;

@Repository
public interface RoleRepository extends MongoRepository<Role, String> {
  Optional<Role> findByName(ERole name);
}

// File: src/main/java/com/in/auth/repository/UserRepository.java

package com.in.auth.repository;

import java.util.Optional;

import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;

import com.in.security.models.User;

@Repository
public interface UserRepository extends MongoRepository<User, String> {
  Optional<User> findByUsername(String username);

  Boolean existsByUsername(String username);

  Boolean existsByEmail(String email);
}

// File: src/main/java/com/in/auth/service/RoleInitializerService.java

package com.in.auth.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.in.security.models.ERole;
import com.in.security.models.Role;
import com.in.auth.repository.RoleRepository;

import jakarta.annotation.PostConstruct;

@Service
public class RoleInitializerService {

    @Autowired
    private RoleRepository roleRepository;

    @PostConstruct
    public void init() {
        if (roleRepository.count() == 0) {
            // Add admin role if no roles exist as default
            Role adminRole = new Role(ERole.ROLE_ADMIN);
            roleRepository.save(adminRole);
        }
    }
}
// File: src/main/java/com/in/auth/service/UserDetailsImpl.java

package com.in.auth.service;

import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.in.security.models.User;


public class UserDetailsImpl implements UserDetails {
  private static final long serialVersionUID = 1L;

  private String id;

  private String username;

  private String email;

  @JsonIgnore
  private String password;

  private Collection<? extends GrantedAuthority> authorities;

  public UserDetailsImpl(String id, String username, String email, String password,
      Collection<? extends GrantedAuthority> authorities) {
    this.id = id;
    this.username = username;
    this.email = email;
    this.password = password;
    this.authorities = authorities;
  }

  public static UserDetailsImpl build(User user) {
    List<GrantedAuthority> authorities = user.getRoles().stream()
        .map(role -> new SimpleGrantedAuthority(role.getName().name()))
        .collect(Collectors.toList());

    return new UserDetailsImpl(
        user.getId(), 
        user.getUsername(), 
        user.getEmail(),
        user.getPassword(), 
        authorities);
  }

  @Override
  public Collection<? extends GrantedAuthority> getAuthorities() {
    return authorities;
  }

  public String getId() {
    return id;
  }

  public String getEmail() {
    return email;
  }

  @Override
  public String getPassword() {
    return password;
  }

  @Override
  public String getUsername() {
    return username;
  }

  @Override
  public boolean isAccountNonExpired() {
    return true;
  }

  @Override
  public boolean isAccountNonLocked() {
    return true;
  }

  @Override
  public boolean isCredentialsNonExpired() {
    return true;
  }

  @Override
  public boolean isEnabled() {
    return true;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o)
      return true;
    if (o == null || getClass() != o.getClass())
      return false;
    UserDetailsImpl user = (UserDetailsImpl) o;
    return Objects.equals(id, user.id);
  }
}

// File: src/main/java/com/in/auth/service/UserDetailsServiceImpl.java

package com.in.auth.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.in.security.models.User;
import com.in.auth.repository.UserRepository;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {
	
  @Autowired
  private UserRepository userRepository;

  @Override
  @Transactional
  public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
      if (username == null) {
          throw new UsernameNotFoundException("User Not Found with username: null");
      }
      
      User user = userRepository.findByUsername(username)
          .orElseThrow(() -> new UsernameNotFoundException("User Not Found with username: " + username));

      return UserDetailsImpl.build(user);
  }

}

// File: src/main/java/com/in/IdentitySecurityManagement.java

package com.in;

import java.util.ArrayList;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;

import com.in.security.models.ERole;
import com.in.security.models.Role;
import com.in.auth.repository.RoleRepository;

import jakarta.annotation.PostConstruct;

@SpringBootApplication
@EnableDiscoveryClient
//@EnableMongoRepositories("com.in.compliance.repository")
//@ComponentScan(basePackages = "com.in.compliance") 
public class IdentitySecurityManagement {

	private static final Logger LOG = LoggerFactory.getLogger(IdentitySecurityManagement.class);
	
	@Autowired(required = true)
	RoleRepository roleRepo;
	
	public static void main(String[] args) {
		SpringApplication.run(IdentitySecurityManagement	.class, args);
	}
	
	@PostConstruct
	public void seeder() {

		List<Role> adminRole = roleRepo.findAll();

		if (!adminRole.isEmpty()) {
			
			//adminRole.stream().
			LOG.info("Volunteer Management App started - Roles "+adminRole.size());

		} else {
			List<Role> roles = new ArrayList<>();
			
			Role roleadmin = new Role();
			roleadmin.setName(ERole.ROLE_ADMIN);
			roles.add(roleadmin);
			
			Role roleMod = new Role();
			roleMod.setName(ERole.ROLE_MODERATOR);
			roles.add(roleMod);
			// roleRepo.save(roleMod);

			Role roleUser = new Role();
			roleUser.setName(ERole.ROLE_USER);
			roles.add(roleUser);
			roleRepo.saveAll(roles);
		}

	}

}

// File: src/main/java/com/in/security/config/SwaggerConfig.java

// File: src/main/java/com/in/security/config/SwaggerConfig.java

package com.in.security.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;


@Configuration
public class SwaggerConfig {
    @Bean
    public OpenAPI customOpenAPI() {
        final String securitySchemeName = "bearerAuth";
        return new OpenAPI()
            .info(new Info()
                .title("Identity Security Management API")
                .version("1.0")
                .description("API documentation for the Identity Security Management application."))
            .addSecurityItem(new SecurityRequirement().addList(securitySchemeName))
            .components(new Components()
                .addSecuritySchemes(securitySchemeName, new SecurityScheme()
                    .name(securitySchemeName)
                    .type(SecurityScheme.Type.HTTP)
                    .scheme("bearer")
                    .bearerFormat("JWT")));
    }
}

// File: src/main/java/com/in/security/config/WebSecurityConfig.java

package com.in.security.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
//import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
//import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
//import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.header.writers.ReferrerPolicyHeaderWriter;

import com.in.security.jwt.AuthEntryPointJwt;
import com.in.security.jwt.AuthTokenFilter;
import com.in.auth.service.UserDetailsServiceImpl;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class WebSecurityConfig {
	@Autowired
	UserDetailsServiceImpl userDetailsService;

	@Autowired
	private AuthEntryPointJwt unauthorizedHandler;

	@Bean
	public AuthTokenFilter authenticationJwtTokenFilter() {
		return new AuthTokenFilter();
	}

//  @Override
//  public void configure(AuthenticationManagerBuilder authenticationManagerBuilder) throws Exception {
//    authenticationManagerBuilder.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
//  }

	@Bean
	public DaoAuthenticationProvider authenticationProvider() {
		DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();

		authProvider.setUserDetailsService(userDetailsService);
		authProvider.setPasswordEncoder(passwordEncoder());

		return authProvider;
	}

//  @Bean
//  @Override
//  public AuthenticationManager authenticationManagerBean() throws Exception {
//    return super.authenticationManagerBean();
//  }

	@Bean
	public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
		return authConfig.getAuthenticationManager();
	}

	@Bean
	public PasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http.csrf(csrf -> csrf.disable())
				.exceptionHandling(exception -> exception.authenticationEntryPoint(unauthorizedHandler))
				.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
				.authorizeHttpRequests(auth -> auth.requestMatchers("/api/auth/**").permitAll()
						//.requestMatchers("/securitymanagement/api/vmt/**").permitAll()
						
						// Allow Swagger UI and API docs without authentication
		                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
						.requestMatchers("/securitymanagement/actuator/**").permitAll()
						.requestMatchers("/securitymanagement/swagger-ui/**").permitAll().anyRequest()
						.authenticated());

		http.authenticationProvider(authenticationProvider());

		http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);

		return http.build();
	}

	/*
	 * @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http)
	 * throws Exception {
	 * 
	 * http // Disable CSRF (useful for stateless APIs, like JWT-based
	 * authentication) .csrf(csrf -> csrf.disable())
	 * 
	 * // Exception handling with custom unauthorized handler
	 * .exceptionHandling(exception -> exception
	 * .authenticationEntryPoint(unauthorizedHandler) )
	 * 
	 * // Stateless session (no session will be created or used by Spring Security)
	 * .sessionManagement(session -> session
	 * .sessionCreationPolicy(SessionCreationPolicy.STATELESS) )
	 * 
	 * // Define authorization rules .authorizeHttpRequests(auth -> auth
	 * .requestMatchers("/compliancemanagement/api/auth/**").permitAll() // Open
	 * access .requestMatchers("/compliancemanagement/api/vmt/**").permitAll() //
	 * Open access .requestMatchers("/compliancemanagement/actuator/**").permitAll()
	 * // Open access to actuator endpoints
	 * .requestMatchers("/compliancemanagement/swagger-ui/**").permitAll() // Open
	 * access to Swagger UI .anyRequest().authenticated() // All other requests
	 * require authentication );
	 * 
	 * // Add security headers http.headers(headers -> headers
	 * .frameOptions(frameOptions -> frameOptions.deny())
	 * .httpStrictTransportSecurity(hsts -> hsts .includeSubDomains(true)
	 * .maxAgeInSeconds(31536000) ) .contentTypeOptions(contentTypeOptions -> {}) //
	 * Prevent MIME-sniffing
	 * 
	 * // Instead of deprecated XSS protection, rely on Content-Security-Policy
	 * .contentSecurityPolicy(csp -> csp
	 * .policyDirectives("default-src 'self'; script-src 'self'; style-src 'self'; img-src 'self';"
	 * ) )
	 * 
	 * .referrerPolicy(referrerPolicy ->
	 * referrerPolicy.policy(ReferrerPolicyHeaderWriter.ReferrerPolicy.NO_REFERRER))
	 * .permissionsPolicy(permissionsPolicy ->
	 * permissionsPolicy.policy("geolocation=(), microphone=(), camera=()")) );
	 * 
	 * return http.build(); }
	 */

}
// File: src/main/java/com/in/security/exception/GlobalExceptionHandler.java

package com.in.security.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;

import com.in.auth.dto.ErrorDetails;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(JwtTokenException.class)
    public ResponseEntity<String> handleJwtTokenExpiredException(JwtTokenException ex) {
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(ex.getMessage());
    }

    @ExceptionHandler(BadCredentialsException.class)
    public ResponseEntity<ErrorDetails> handleBadCredentialsException(BadCredentialsException ex, WebRequest request) {
        ErrorDetails errorDetails = new ErrorDetails(
            HttpStatus.UNAUTHORIZED.value(), 
            "Invalid credentials", 
            request.getDescription(false)
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.UNAUTHORIZED);
    }

    // Handle global exceptions
    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleGlobalException(Exception ex, WebRequest request) {
        ErrorDetails errorDetails = new ErrorDetails(
            HttpStatus.INTERNAL_SERVER_ERROR.value(), 
            ex.getMessage(),
            request.getDescription(false)
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
// File: src/main/java/com/in/security/exception/InvalidUidException.java

package com.in.security.exception;

public class InvalidUidException extends Exception {

    public InvalidUidException(String msg) {
        super(msg);
    }
}

// File: src/main/java/com/in/security/exception/JwtTokenException.java

package com.in.security.exception;

public class JwtTokenException extends RuntimeException {
    /**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	public JwtTokenException(String message) {
        super(message);
    }

}

// File: src/main/java/com/in/security/exception/NotFoundExceptions.java

package com.in.security.exception;

public class NotFoundExceptions extends Exception {

    public NotFoundExceptions(String message) {
        super(message);
    }
}

// File: src/main/java/com/in/security/exception/UnauthorisedRoleExceptions.java

package com.in.security.exception;

public class UnauthorisedRoleExceptions extends Exception {
    public UnauthorisedRoleExceptions(String message) {
        super(message);
    }
}
// File: src/main/java/com/in/security/exception/UnauthorisedSignInException.java

package com.in.security.exception;

public class UnauthorisedSignInException extends Exception {
    public UnauthorisedSignInException(String message) {
        super(message);
    }
}

// File: src/main/java/com/in/security/jwt/AuthEntryPointJwt.java

package com.in.security.jwt;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import com.fasterxml.jackson.databind.ObjectMapper;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

@Component
public class AuthEntryPointJwt implements AuthenticationEntryPoint {

  private static final Logger logger = LoggerFactory.getLogger(AuthEntryPointJwt.class);

  @Override
  public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
      throws IOException, ServletException {
    logger.error("Unauthorized error: {}", authException.getMessage());

    response.setContentType(MediaType.APPLICATION_JSON_VALUE);
    response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

    final Map<String, Object> body = new HashMap<>();
    body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
    body.put("error", "Unauthorized");
    body.put("message", authException.getMessage());
    body.put("path", request.getServletPath());

    final ObjectMapper mapper = new ObjectMapper();
    mapper.writeValue(response.getOutputStream(), body);
  }

}

// File: src/main/java/com/in/security/jwt/AuthTokenFilter.java

package com.in.security.jwt;

import java.io.IOException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import com.in.auth.service.*;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;


@Component
public class AuthTokenFilter extends OncePerRequestFilter {
  @Autowired
  private JwtUtils jwtUtils;

  @Autowired
  private UserDetailsServiceImpl userDetailsService;

  private static final Logger logger = LoggerFactory.getLogger(AuthTokenFilter.class);

  @Override
  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
      throws ServletException, IOException {
    try {
      String jwt = parseJwt(request);
           
      if (jwt != null && jwtUtils.validateJwtToken(jwt)) {
        String username = jwtUtils.getUserNameFromJwtToken(jwt);

        UserDetails userDetails = userDetailsService.loadUserByUsername(username);
        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null,
            userDetails.getAuthorities());
        authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

        SecurityContextHolder.getContext().setAuthentication(authentication);
      }
      
		
		/*
		 * } catch (JwtTokenException exp) { throw exp; throw new
		 * AuthenticationException(exp.getMessage())
		 */
    } catch (Exception e) {
      logger.error("Cannot set user authentication: {}", e);
      request.setAttribute("JWT_MSG", e.getMessage());
    }

    filterChain.doFilter(request, response);
  }

  private String parseJwtFromCookies(HttpServletRequest request) {
    String jwt = jwtUtils.getJwtFromCookies(request);
    return jwt;
  }
  
  private String parseJwt(HttpServletRequest request) {
	  String jwt =request.getHeader("Authorization");
	  if(jwt != null && jwt.startsWith("Bearer ")) {
		  jwt=jwt.substring(7);
	  }
	    return jwt;
	  }
}

// File: src/main/java/com/in/security/jwt/JwtUtils.java

package com.in.security.jwt;


import java.security.Key;
import java.util.Date;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseCookie;
import org.springframework.stereotype.Component;
import org.springframework.web.util.WebUtils;

import com.in.auth.service.UserDetailsImpl;

import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.UnsupportedJwtException;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;

@Component
public class JwtUtils {
   private static final Logger LOG = LoggerFactory.getLogger(JwtUtils.class);


  @Value("${security.app.jwtSecret}")
  private String jwtSecret;

  @Value("${security.app.jwtExpirationMs}")
  private long jwtExpirationMs;

  @Value("${security.app.jwtCookieName}")
  private String jwtCookie;
  


  public String getJwtFromCookies(HttpServletRequest request) {
    Cookie cookie = WebUtils.getCookie(request, jwtCookie);
    if (cookie != null) {
      return cookie.getValue();
    } else {
      return null;
    }
  }

  public ResponseCookie generateJwtCookie(UserDetailsImpl userPrincipal) {
    String jwt = generateTokenFromUsername(userPrincipal.getUsername());
    return ResponseCookie.from(jwtCookie, jwt)
            .path("/api")
            .maxAge(jwtExpirationMs)
            .httpOnly(true)
            .build();

  }

  public String generateToken(UserDetailsImpl userPrincipal) {
	    return  generateTokenFromUsername(userPrincipal.getUsername());
	  }
  
  public ResponseCookie getCleanJwtCookie() {
    ResponseCookie cookie = ResponseCookie.from(jwtCookie, null).path("/api").build();
    return cookie;
  }

  public String getUserNameFromJwtToken(String token) {
    return Jwts.parserBuilder().setSigningKey(key()).build()
        .parseClaimsJws(token).getBody().getSubject();
  }
  
  private Key key() {
    return Keys.hmacShaKeyFor(Decoders.BASE64.decode(jwtSecret));
  }

  public boolean validateJwtToken(String authToken) {
	  LOG.info("Start Method:validateJwtToken");
    try {
      Jwts.parserBuilder().setSigningKey(key()).build().parse(authToken);
      return true;
    } catch (MalformedJwtException e) {
    	LOG.error("Invalid JWT token: {}", e.getMessage());
      //throw new JwtTokenException("Invalid JWT token:"+e.getMessage());
    } catch (ExpiredJwtException e) {
    	LOG.error("JWT token is expired: {}", e.getMessage());
     // throw new JwtTokenException("JWT token is expired: "+e.getMessage());
    } catch (UnsupportedJwtException e) {
    	LOG.error("JWT token is unsupported: {}", e.getMessage());
     // throw new JwtTokenException("JWT token is unsupported:"+e.getMessage());
    } catch (IllegalArgumentException e) {
    	LOG.error("JWT claims string is empty: {}", e.getMessage());
      //throw new JwtTokenException("JWT claims string is empty:"+e.getMessage());
    }

   return false;
  }
  
  public String generateTokenFromUsername(String username) {   
	  LOG.info("Start Method:generateTokenFromUsername");
    return Jwts.builder()
              .setSubject(username)
              .setIssuedAt(new Date())
              .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))
              .signWith(key(), SignatureAlgorithm.HS256)
              .compact();
  }
}

// File: src/main/java/com/in/security/models/ERole.java

package com.in.security.models;

public enum ERole {
  ROLE_USER,
  ROLE_MODERATOR,
  ROLE_ADMIN
}

// File: src/main/java/com/in/security/models/Role.java

package com.in.security.models;

import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

@Document(collection = "roles")
public class Role {
  @Id
  private String id;

  private ERole name;

  public Role() {

  }

  public Role(ERole name) {
    this.name = name;
  }

  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public ERole getName() {
    return name;
  }

  public void setName(ERole name) {
    this.name = name;
  }
}

// File: src/main/java/com/in/security/models/User.java

package com.in.security.models;

import java.util.HashSet;
import java.util.Set;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.DBRef;
import org.springframework.data.mongodb.core.mapping.Document;

@Document(collection = "users")
public class User {
  @Id
  private String id;

  @NotBlank
  @Size(max = 20)
  private String username;

  @NotBlank
  @Size(max = 50)
  @Email
  private String email;

  @NotBlank
  @Size(max = 120)
  private String password;

  @DBRef
  private Set<Role> roles = new HashSet<>();

  public User() {
  }

  public User(String username, String email, String password) {
    this.username = username;
    this.email = email;
    this.password = password;
  }

  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public String getUsername() {
    return username;
  }

  public void setUsername(String username) {
    this.username = username;
  }

  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }

  // Return a masked password when requested
  public String getPassword() {
      return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  public Set<Role> getRoles() {
    return roles;
  }

  public void setRoles(Set<Role> roles) {
    this.roles = roles;
  }
}

// File: src/main/java/com/in/security/util/AppConstants.java

package com.in.security.util;

public class AppConstants {
	
	private AppConstants() {
		
	}
	public static final String ROLE_NOTFOUND="Error: Role is not found.";

}


Java Files from src/test/java:


// File: src/test/java/com/in/auth/controller/AuthControllerTest.java

package com.in.auth.controller;

import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

import java.util.*;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.test.web.servlet.MockMvc;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.in.auth.payload.request.LoginRequest;
import com.in.auth.payload.request.SignupRequest;
import com.in.auth.repository.RoleRepository;
import com.in.auth.repository.UserRepository;
import com.in.auth.service.UserDetailsImpl;
import com.in.security.jwt.JwtUtils;
import com.in.security.models.ERole;
import com.in.security.models.Role;
import com.in.security.models.User;
import com.in.auth.test.TestResultLoggerExtension;

/**
 * Comprehensive test class for the AuthController.
 * This class tests the authentication and registration endpoints.
 */
@SpringBootTest 
@AutoConfigureMockMvc // Automatically configures MockMvc
@ExtendWith(TestResultLoggerExtension.class) // Extends the test with our custom TestResultLoggerExtension
public class AuthControllerTest {

    // Logger for this test class
    private static final Logger logger = LoggerFactory.getLogger(AuthControllerTest.class);

    @Autowired
    private MockMvc mockMvc; // MockMvc is used to perform and verify HTTP requests and responses

    @Autowired
    private ObjectMapper objectMapper; // ObjectMapper is used to convert Java objects to JSON and vice versa

    // Mock beans are used to simulate the behavior of these components without actually invoking them
    @MockBean
    private AuthenticationManager authenticationManager;

    @MockBean
    private UserRepository userRepository;

    @MockBean
    private RoleRepository roleRepository;

    @MockBean
    private PasswordEncoder encoder;

    @MockBean
    private JwtUtils jwtUtils;

    // These objects will be used across multiple tests
    private LoginRequest validLoginRequest;
    private SignupRequest validSignupRequest;

    /**
     * Set up test data before each test method.
     */
    @BeforeEach
    public void setup() {
        // Initialize a valid login request
        validLoginRequest = new LoginRequest("testuser", "testpassword");

        // Initialize a valid signup request
        validSignupRequest = new SignupRequest("newuser", "newuser@example.com", new HashSet<>(Collections.singletonList("user")));
        validSignupRequest.setPassword("newpassword");
    }

    /**
     * Test successful user authentication.
     * This test verifies that a user can successfully authenticate and receive a JWT token.
     */
    @Test
    @DisplayName("Authenticate User - Success")
    public void testAuthenticateUser_Success() throws Exception {
        // Arrange: Set up the test scenario
        UserDetailsImpl userDetails = new UserDetailsImpl("1", "testuser", "test@example.com", "testpassword", Collections.emptyList());
        Authentication authentication = new UsernamePasswordAuthenticationToken(userDetails, null);
        
        // Mock the behavior of the authentication manager and JWT utils
        when(authenticationManager.authenticate(any())).thenReturn(authentication);
        when(jwtUtils.generateToken(any(UserDetailsImpl.class))).thenReturn("test.jwt.token");

        // Act and Assert: Perform the request and verify the response
        mockMvc.perform(post("/securitymanagement/api/auth/signin")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(validLoginRequest)))
                .andExpect(status().isOk()) // Expect a 200 OK status
                .andExpect(header().string("Authorization", "test.jwt.token")) // Verify the JWT token in the header
                .andExpect(jsonPath("$.username").value("testuser")) // Verify the username in the response body
                .andExpect(jsonPath("$.email").value("test@example.com")); // Verify the email in the response body

        // Verify that the authentication manager was called with the correct credentials
        verify(authenticationManager).authenticate(
                new UsernamePasswordAuthenticationToken(validLoginRequest.getUsername(), validLoginRequest.getPassword()));
    }

    /**
     * Test authentication failure due to invalid credentials.
     * This test verifies that the system correctly handles authentication attempts with invalid credentials.
     */
    @Test
    @DisplayName("Authenticate User - Invalid Credentials")
    public void testAuthenticateUser_InvalidCredentials() throws Exception {
        // Arrange: Set up the test scenario for invalid credentials
        when(authenticationManager.authenticate(any())).thenThrow(new BadCredentialsException("Invalid credentials"));

        // Act and Assert: Perform the request with invalid credentials and verify the response
        mockMvc.perform(post("/securitymanagement/api/auth/signin")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(validLoginRequest)))
                .andExpect(status().isUnauthorized()); // Expect a 401 Unauthorized status

        // Verify that the authentication manager was called with the provided credentials
        verify(authenticationManager).authenticate(
                new UsernamePasswordAuthenticationToken(validLoginRequest.getUsername(), validLoginRequest.getPassword()));
    }

    /**
     * Test successful user registration.
     * This test verifies that a new user can be successfully registered in the system.
     */
    @Test
    @DisplayName("Register User - Success")
    public void testRegisterUser_Success() throws Exception {
        // Arrange: Set up the test scenario for successful user registration
        when(userRepository.existsByUsername(validSignupRequest.getUsername())).thenReturn(false);
        when(userRepository.existsByEmail(validSignupRequest.getEmail())).thenReturn(false);
        when(roleRepository.findByName(ERole.ROLE_USER)).thenReturn(Optional.of(new Role(ERole.ROLE_USER)));
        when(encoder.encode(validSignupRequest.getPassword())).thenReturn("encodedPassword");
        when(userRepository.save(any(User.class))).thenReturn(new User(validSignupRequest.getUsername(), validSignupRequest.getEmail(), "encodedPassword"));

        // Act and Assert: Perform the signup request and verify the response
        mockMvc.perform(post("/securitymanagement/api/auth/signup")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(validSignupRequest)))
                .andExpect(status().isOk()) // Expect a 200 OK status
                .andExpect(jsonPath("$.message").value("User registered successfully!")); // Verify the success message

        // Verify that the user repository was called to save the new user
        verify(userRepository).save(any(User.class));
    }

    /**
     * Test registration failure due to username already taken.
     * This test verifies that the system correctly handles registration attempts with an existing username.
     */
    @Test
    @DisplayName("Register User - Username Already Taken")
    public void testRegisterUser_UsernameAlreadyTaken() throws Exception {
        // Arrange: Set up the test scenario for a username that's already taken
        when(userRepository.existsByUsername(validSignupRequest.getUsername())).thenReturn(true);

        // Act and Assert: Perform the signup request and verify the response
        mockMvc.perform(post("/securitymanagement/api/auth/signup")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(validSignupRequest)))
                .andExpect(status().isBadRequest()) // Expect a 400 Bad Request status
                .andExpect(jsonPath("$.message").value("Error: Username is already taken! " + validSignupRequest.getUsername()));

        // Verify that the user repository was not called to save the user
        verify(userRepository, never()).save(any(User.class));
    }

    /**
     * Test registration failure due to email already in use.
     * This test verifies that the system correctly handles registration attempts with an existing email.
     */
    @Test
    @DisplayName("Register User - Email Already in Use")
    public void testRegisterUser_EmailAlreadyInUse() throws Exception {
        // Arrange: Set up the test scenario for an email that's already in use
        when(userRepository.existsByUsername(validSignupRequest.getUsername())).thenReturn(false);
        when(userRepository.existsByEmail(validSignupRequest.getEmail())).thenReturn(true);

        // Act and Assert: Perform the signup request and verify the response
        mockMvc.perform(post("/securitymanagement/api/auth/signup")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(validSignupRequest)))
                .andExpect(status().isBadRequest()) // Expect a 400 Bad Request status
                .andExpect(jsonPath("$.message").value("Error: Email is already in use!"));

        // Verify that the user repository was not called to save the user
        verify(userRepository, never()).save(any(User.class));
    }

    /**
     * Test registration failure due to role not found.
     * This test verifies that the system correctly handles registration attempts when the default role is not found.
     */
    @Test
    @DisplayName("Register User - Role Not Found")
    public void testRegisterUser_RoleNotFound() throws Exception {
        // Arrange: Set up the test scenario where the user role is not found
        when(userRepository.existsByUsername(validSignupRequest.getUsername())).thenReturn(false);
        when(userRepository.existsByEmail(validSignupRequest.getEmail())).thenReturn(false);
        when(roleRepository.findByName(ERole.ROLE_USER)).thenReturn(Optional.empty());

        // Act and Assert: Perform the signup request and verify the response
        mockMvc.perform(post("/securitymanagement/api/auth/signup")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(validSignupRequest)))
                .andExpect(status().isInternalServerError()); // Expect a 500 Internal Server Error status

        // Verify that the user repository was not called to save the user
        verify(userRepository, never()).save(any(User.class));
    }

    /**
     * Print a summary of all test results after all tests have completed.
     */
    @AfterAll
    static void printTestSummary() {
        List<String> testResults = TestResultLoggerExtension.getTestResults();
        logger.info("==== Test Summary ====");
        int totalTests = testResults.size();
        long passedTests = testResults.stream().filter(result -> result.contains("PASSED")).count();
        logger.info("Total Tests: {}", totalTests);
        logger.info("Passed: {}", passedTests);
        logger.info("Failed: {}", totalTests - passedTests);
        logger.info("==== Detailed Results ====");
        testResults.forEach(logger::info);
    }
}
// File: src/test/java/com/in/auth/service/UserDetailsServiceImplTest.java

package com.in.auth.service;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;

import com.in.auth.repository.UserRepository;
import com.in.security.models.ERole;
import com.in.security.models.Role;
import com.in.security.models.User;
import com.in.auth.test.TestResultLoggerExtension;

/**
 * Comprehensive test class for the UserDetailsServiceImpl.
 * This class tests the user details loading functionality.
 */
@SpringBootTest
@ExtendWith(TestResultLoggerExtension.class)
public class UserDetailsServiceImplTest {

    private static final Logger logger = LoggerFactory.getLogger(UserDetailsServiceImplTest.class);

    @Autowired
    private UserDetailsServiceImpl userDetailsService;

    @MockBean
    private UserRepository userRepository;

    private User testUser;

    /**
     * Set up test data before each test method.
     */
    @BeforeEach
    public void setup() {
        // Initialize a test user with a role
        testUser = new User("testuser", "test@example.com", "password");
        testUser.setId("1");
        Role userRole = new Role(ERole.ROLE_USER);
        testUser.setRoles(Collections.singleton(userRole));
    }

    /**
     * Test successful loading of user details.
     * This test verifies that a user can be successfully loaded by username.
     */
    @Test
    @DisplayName("Load User By Username - Success")
    public void testLoadUserByUsername_Success() {
        // Arrange
        when(userRepository.findByUsername("testuser")).thenReturn(Optional.of(testUser));

        // Act
        UserDetails userDetails = userDetailsService.loadUserByUsername("testuser");

        // Assert
        assertNotNull(userDetails, "UserDetails should not be null");
        assertEquals("testuser", userDetails.getUsername(), "Username should match");
        assertEquals("password", userDetails.getPassword(), "Password should match");
        assertTrue(userDetails.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals("ROLE_USER")), "User should have ROLE_USER authority");

        // Verify that the user repository was called
        verify(userRepository).findByUsername("testuser");
    }

    /**
     * Test loading user details with a non-existent username.
     * This test verifies that the correct exception is thrown when a user is not found.
     */
    @Test
    @DisplayName("Load User By Username - User Not Found")
    public void testLoadUserByUsername_UserNotFound() {
        // Arrange
        when(userRepository.findByUsername("nonexistent")).thenReturn(Optional.empty());

        // Act & Assert
        Exception exception = assertThrows(UsernameNotFoundException.class, () -> {
            userDetailsService.loadUserByUsername("nonexistent");
        }, "Should throw UsernameNotFoundException");

        assertEquals("User Not Found with username: nonexistent", exception.getMessage(),
                "Exception message should match");

        // Verify that the user repository was called
        verify(userRepository).findByUsername("nonexistent");
    }

    /**
     * Test loading user details with a null username.
     * This test verifies that the service handles null input by throwing a UsernameNotFoundException.
     */
    @Test
    @DisplayName("Load User By Username - Null Username")
    public void testLoadUserByUsername_NullUsername() {
        // Act & Assert
        Exception exception = assertThrows(UsernameNotFoundException.class, () -> {
            userDetailsService.loadUserByUsername(null);
        }, "Should throw UsernameNotFoundException for null username");

        assertEquals("User Not Found with username: null", exception.getMessage(),
                "Exception message should match");

        // Verify that the user repository was not called
        verify(userRepository, never()).findByUsername(any());
    }
    /**
     * Test loading user details for a user with multiple roles.
     * This test verifies that all roles are correctly mapped to authorities.
     */
    @Test
    @DisplayName("Load User By Username - Multiple Roles")
    public void testLoadUserByUsername_MultipleRoles() {
        // Arrange
        User multiRoleUser = new User("multiuser", "multi@example.com", "password");
        multiRoleUser.setId("2");
        multiRoleUser.setRoles(Set.of(new Role(ERole.ROLE_USER), new Role(ERole.ROLE_ADMIN)));
        when(userRepository.findByUsername("multiuser")).thenReturn(Optional.of(multiRoleUser));

        // Act
        UserDetails userDetails = userDetailsService.loadUserByUsername("multiuser");

        // Assert
        assertNotNull(userDetails, "UserDetails should not be null");
        assertEquals("multiuser", userDetails.getUsername(), "Username should match");
        assertEquals(2, userDetails.getAuthorities().size(), "User should have 2 authorities");
        assertTrue(userDetails.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals("ROLE_USER")), "User should have ROLE_USER authority");
        assertTrue(userDetails.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN")), "User should have ROLE_ADMIN authority");

        // Verify that the user repository was called
        verify(userRepository).findByUsername("multiuser");
    }


    /**
     * Print a summary of all test results after all tests have completed.
     */
    @AfterAll
    static void printTestSummary() {
        List<String> testResults = TestResultLoggerExtension.getTestResults();
        logger.info("==== Test Summary ====");
        int totalTests = testResults.size();
        long passedTests = testResults.stream().filter(result -> result.contains("PASSED")).count();
        logger.info("Total Tests: {}", totalTests);
        logger.info("Passed: {}", passedTests);
        logger.info("Failed: {}", totalTests - passedTests);
        logger.info("==== Detailed Results ====");
        testResults.forEach(logger::info);
    }
}
// File: src/test/java/com/in/auth/test/TestResultLoggerExtension.java

package com.in.auth.test;

import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.extension.TestWatcher;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;

/**
 * Custom TestWatcher extension to log test results.
 */
public class TestResultLoggerExtension implements TestWatcher {

    private static final Logger logger = LoggerFactory.getLogger(TestResultLoggerExtension.class);

    // Static list to store test results across all tests
    private static List<String> testResults = new ArrayList<>();

    @Override
    public void testSuccessful(ExtensionContext context) {
        String testName = context.getDisplayName();
        String logMessage = String.format("Test: %s - PASSED", testName);
        logger.info(logMessage);
        testResults.add(logMessage);
    }

    @Override
    public void testFailed(ExtensionContext context, Throwable cause) {
        String testName = context.getDisplayName();
        String logMessage = String.format("Test: %s - FAILED - Reason: %s", testName, cause.getMessage());
        logger.info(logMessage);
        testResults.add(logMessage);
    }

    /**
     * Provides access to the test results.
     * @return List of test result messages.
     */
    public static List<String> getTestResults() {
        return testResults;
    }
}
// File: src/test/java/com/in/security/jwt/AuthTokenFilterTest.java

// File: src/test/java/com/in/security/jwt/AuthTokenFilterTest.java

package com.in.security.jwt;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import java.io.IOException;
import java.util.Collections;
import java.util.List;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
// Import MockitoExtension to enable Mockito annotations
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.test.util.ReflectionTestUtils;

import com.in.auth.service.UserDetailsImpl;
import com.in.auth.service.UserDetailsServiceImpl;
import com.in.auth.test.TestResultLoggerExtension;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Comprehensive test class for the AuthTokenFilter.
 * This class tests the doFilterInternal method for various scenarios.
 */
@ExtendWith(MockitoExtension.class) // Enable Mockito annotations
@ExtendWith(TestResultLoggerExtension.class) // Custom extension for logging
public class AuthTokenFilterTest {

    private static final Logger logger = LoggerFactory.getLogger(AuthTokenFilterTest.class);

    @InjectMocks
    private AuthTokenFilter authTokenFilter;

    @Mock
    private JwtUtils jwtUtils;

    @Mock
    private UserDetailsServiceImpl userDetailsService;

    @Mock
    private HttpServletRequest request;

    @Mock
    private HttpServletResponse response;

    @Mock
    private FilterChain filterChain;

    private UserDetailsImpl userDetails;

    /**
     * Set up test data and inject mocks into private fields.
     */
    @BeforeEach
    public void setUp() {
        // Initialize a test user
        userDetails = new UserDetailsImpl("1", "testuser", "test@example.com", "password", Collections.emptyList());

        // Inject mocks into the private fields of authTokenFilter
       // Uses ReflectionTestUtils.setField to inject the mocked jwtUtils and userDetailsService into the authTokenFilter
       // This is necessary because these fields are private and don't have setters
        ReflectionTestUtils.setField(authTokenFilter, "jwtUtils", jwtUtils);
        ReflectionTestUtils.setField(authTokenFilter, "userDetailsService", userDetailsService);
    }

    /**
     * Test case for a valid JWT token.
     * Expectation: Authentication should be set in the SecurityContextHolder.
     */
    @Test
    @DisplayName("doFilterInternal - Valid JWT Token")
    public void testDoFilterInternal_ValidToken() throws ServletException, IOException {
        // Arrange
        String token = "valid.jwt.token";
        when(request.getHeader("Authorization")).thenReturn("Bearer " + token);
        when(jwtUtils.validateJwtToken(token)).thenReturn(true);
        when(jwtUtils.getUserNameFromJwtToken(token)).thenReturn("testuser");
        when(userDetailsService.loadUserByUsername("testuser")).thenReturn(userDetails);

        // Act
        authTokenFilter.doFilterInternal(request, response, filterChain);

        // Assert
        assertNotNull(SecurityContextHolder.getContext().getAuthentication(), "Authentication should be set");
        assertEquals("testuser", SecurityContextHolder.getContext().getAuthentication().getName(), "Username should match");
        verify(filterChain).doFilter(request, response);
    }

    /**
     * Test case for an invalid JWT token.
     * Expectation: Authentication should not be set in the SecurityContextHolder.
     */
    @Test
    @DisplayName("doFilterInternal - Invalid JWT Token")
    public void testDoFilterInternal_InvalidToken() throws ServletException, IOException {
        // Arrange
        String token = "invalid.jwt.token";
        when(request.getHeader("Authorization")).thenReturn("Bearer " + token);
        when(jwtUtils.validateJwtToken(token)).thenReturn(false);

        // Act
        authTokenFilter.doFilterInternal(request, response, filterChain);

        // Assert
        assertNull(SecurityContextHolder.getContext().getAuthentication(), "Authentication should not be set");
        verify(filterChain).doFilter(request, response);
    }

    /**
     * Test case for missing JWT token.
     * Expectation: Authentication should not be set in the SecurityContextHolder.
     */
    @Test
    @DisplayName("doFilterInternal - Missing JWT Token")
    public void testDoFilterInternal_MissingToken() throws ServletException, IOException {
        // Arrange
        when(request.getHeader("Authorization")).thenReturn(null);

        // Act
        authTokenFilter.doFilterInternal(request, response, filterChain);

        // Assert
        assertNull(SecurityContextHolder.getContext().getAuthentication(), "Authentication should not be set");
        verify(filterChain).doFilter(request, response);
    }

    /**
     * Test case for expired JWT token.
     * Expectation: Authentication should not be set, exception should be handled gracefully.
     */
    @Test
    @DisplayName("doFilterInternal - Expired JWT Token")
    public void testDoFilterInternal_ExpiredToken() throws ServletException, IOException {
        // Arrange
        String token = "expired.jwt.token";
        when(request.getHeader("Authorization")).thenReturn("Bearer " + token);
        doThrow(new RuntimeException("JWT token is expired")).when(jwtUtils).validateJwtToken(token);

        // Act
        authTokenFilter.doFilterInternal(request, response, filterChain);

        // Assert
        assertNull(SecurityContextHolder.getContext().getAuthentication(), "Authentication should not be set");
        verify(filterChain).doFilter(request, response);
        // Verify that the exception message is set as a request attribute
        verify(request).setAttribute("JWT_MSG", "JWT token is expired");
    }

    /**
     * Test case when an exception occurs during authentication.
     * Expectation: Exception should be caught, and authentication should not be set.
     */
    @Test
    @DisplayName("doFilterInternal - Exception Handling")
    public void testDoFilterInternal_ExceptionHandling() throws ServletException, IOException {
        // Arrange
        String token = "some.jwt.token";
        when(request.getHeader("Authorization")).thenReturn("Bearer " + token);
        doThrow(new RuntimeException("Unexpected error")).when(jwtUtils).validateJwtToken(token);

        // Act
        authTokenFilter.doFilterInternal(request, response, filterChain);

        // Assert
        assertNull(SecurityContextHolder.getContext().getAuthentication(), "Authentication should not be set");
        verify(filterChain).doFilter(request, response);
        verify(request).setAttribute("JWT_MSG", "Unexpected error");
    }

    /**
     * Clean up after all tests.
     * Print a summary of all test results.
     */
    @AfterAll
    static void printTestSummary() {
        // Retrieve test results from the custom TestResultLoggerExtension
        List<String> testResults = TestResultLoggerExtension.getTestResults();

        logger.info("==== Test Summary ====");
        int totalTests = testResults.size();
        long passedTests = testResults.stream().filter(result -> result.contains("PASSED")).count();
        logger.info("Total Tests: {}", totalTests);
        logger.info("Passed: {}", passedTests);
        logger.info("Failed: {}", totalTests - passedTests);
        logger.info("==== Detailed Results ====");
        testResults.forEach(logger::info);
    }
}

// File: src/test/java/com/in/security/jwt/JwtUtilsTest.java

package com.in.security.jwt;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.util.Date;
import java.util.List;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.security.core.Authentication;
import org.springframework.test.util.ReflectionTestUtils;

import com.in.auth.service.UserDetailsImpl;
import com.in.auth.test.TestResultLoggerExtension;

import io.jsonwebtoken.ExpiredJwtException;

/**
 * Comprehensive test class for the JwtUtils.
 * This class tests JWT token generation, validation, and parsing.
 */
@SpringBootTest
@ExtendWith(TestResultLoggerExtension.class)
public class JwtUtilsTest {

    private static final Logger logger = LoggerFactory.getLogger(JwtUtilsTest.class);

    @Autowired
    private JwtUtils jwtUtils;

    @Mock
    private Authentication authentication;

    private UserDetailsImpl userDetails;
    private static final String TEST_JWT_SECRET = "testSecretKeyWhichIsLongEnoughForHS256Algorithm";
    private static final long TEST_JWT_EXPIRATION = 60000; // 1 minute

    /**
     * Set up test data and configure JwtUtils before each test method.
     */
    @BeforeEach
    public void setup() {
        userDetails = new UserDetailsImpl("1", "testuser", "test@example.com", "password", List.of());
        ReflectionTestUtils.setField(jwtUtils, "jwtSecret", TEST_JWT_SECRET);
        ReflectionTestUtils.setField(jwtUtils, "jwtExpirationMs", TEST_JWT_EXPIRATION);
    }

    /**
     * Test successful JWT token generation.
     * This test verifies that a token can be generated for a valid user.
     */
    @Test
    @DisplayName("Generate Token - Success")
    public void testGenerateToken_Success() {
        // Arrange
        when(authentication.getPrincipal()).thenReturn(userDetails);

        // Act
        String token = jwtUtils.generateToken(userDetails);

        // Assert
        assertNotNull(token, "Generated token should not be null");
        assertTrue(token.length() > 0, "Generated token should not be empty");
    }

    /**
     * Test successful JWT token validation.
     * This test verifies that a valid token can be successfully validated.
     */
    @Test
    @DisplayName("Validate Token - Success")
    public void testValidateJwtToken_Success() {
        // Arrange
        String token = jwtUtils.generateToken(userDetails);

        // Act
        boolean isValid = jwtUtils.validateJwtToken(token);

        // Assert
        assertTrue(isValid, "Token should be valid");
    }

    /**
     * Test JWT token validation with an expired token.
     * This test verifies that an expired token is correctly identified as invalid.
     */
    @Test
    @DisplayName("Validate Token - Expired")
    public void testValidateJwtToken_Expired() {
        // Arrange
        ReflectionTestUtils.setField(jwtUtils, "jwtExpirationMs", 1); // Set expiration to 1ms
        String token = jwtUtils.generateToken(userDetails);

        // Act & Assert
        assertFalse(jwtUtils.validateJwtToken(token), "Expired token should be invalid");
    }

    /**
     * Test JWT token validation with an invalid token.
     * This test verifies that an improperly formatted token is identified as invalid.
     */
    @Test
    @DisplayName("Validate Token - Invalid Format")
    public void testValidateJwtToken_InvalidFormat() {
        // Arrange
        String invalidToken = "invalid.token.format";

        // Act & Assert
        assertFalse(jwtUtils.validateJwtToken(invalidToken), "Improperly formatted token should be invalid");
    }

    /**
     * Test extracting username from a valid JWT token.
     * This test verifies that the correct username can be extracted from a valid token.
     */
    @Test
    @DisplayName("Get Username From Token - Success")
    public void testGetUserNameFromJwtToken_Success() {
        // Arrange
        String token = jwtUtils.generateToken(userDetails);

        // Act
        String extractedUsername = jwtUtils.getUserNameFromJwtToken(token);

        // Assert
        assertEquals(userDetails.getUsername(), extractedUsername, "Extracted username should match the original");
    }

    /**
     * Test extracting username from an expired JWT token.
     * This test verifies that attempting to extract a username from an expired token throws an exception.
     */
    @Test
    @DisplayName("Get Username From Token - Expired Token")
    public void testGetUserNameFromJwtToken_ExpiredToken() {
        // Arrange
        ReflectionTestUtils.setField(jwtUtils, "jwtExpirationMs", 1); // Set expiration to 1ms
        String token = jwtUtils.generateToken(userDetails);

        // Act & Assert
        assertThrows(ExpiredJwtException.class, () -> jwtUtils.getUserNameFromJwtToken(token),
                "Extracting username from expired token should throw ExpiredJwtException");
    }

    /**
     * Print a summary of all test results after all tests have completed.
     */
    @AfterAll
    static void printTestSummary() {
        List<String> testResults = TestResultLoggerExtension.getTestResults();
        logger.info("==== Test Summary ====");
        int totalTests = testResults.size();
        long passedTests = testResults.stream().filter(result -> result.contains("PASSED")).count();
        logger.info("Total Tests: {}", totalTests);
        logger.info("Passed: {}", passedTests);
        logger.info("Failed: {}", totalTests - passedTests);
        logger.info("==== Detailed Results ====");
        testResults.forEach(logger::info);
    }
}

Resource Files from src/main/resources:


// File: src/main/resources/application.properties


#Local mongoDB
#spring.data.mongodb.database=identityManagement
#spring.data.mongodb.host=localhost
#spring.data.mongodb.port=27017

spring.application.name=identity-security-management

# Eureka client configuration
#eureka.client.serviceUrl.defaultZone=http://139.59.67.255:8761/eureka/
#eureka.instance.preferIpAddress=true
#eureka.instance.ip-address=${IDENTITY_SERVICE_IP:localhost}

# JWT Configuration
security.app.jwtCookieName=neocompliance
security.app.jwtSecret=${JWT_SECRET:3neo38792F423F4428472B4B6250655368566D597133743677397A244326test}
security.app.jwtExpirationMs=86400000

# MongoDB Configuration
spring.data.mongodb.uri=mongodb+srv://moderator:1s89026mS4Hp7eNZ@db-mongodb-blr1-vms-59c60299.mongo.ondigitalocean.com/identityManagement?tls=true&authSource=admin&replicaSet=db-mongodb-blr1-vms
spring.data.mongodb.socketTimeout=60000
spring.data.mongodb.connectTimeout=60000
spring.data.mongodb.serverSelectionTimeout=60000

# Server port (choose a unique port for this service)
server.port=8081

Resource Files from src/test/resources:



POM File (pom.xml):


// File: pom.xml

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.3.3</version>
		<relativePath /> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.in</groupId>
	<artifactId>identity-security-management</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>identity-security-management</name>
	<description>identity-security-management springboot app</description>
	<url />
	<licenses>
		<license />
	</licenses>
	<developers>
		<developer />
	</developers>
	<scm>
		<connection />
		<developerConnection />
		<tag />
		<url />
	</scm>
	<properties>
		<java.version>17</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
			<dependency>
			<groupId>org.mongodb</groupId>
			<artifactId>mongodb-driver-sync</artifactId>
			<version>5.1.3</version>
		</dependency>
		
				<dependency>
		    <groupId>org.mockito</groupId>
		    <artifactId>mockito-core</artifactId>
		    <version>5.4.0</version>
		    <scope>test</scope>
		</dependency>
		
				<!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-eureka-client -->
		<dependency>
		    <groupId>org.springframework.cloud</groupId>
		    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		    <version>4.1.3</version>
		</dependency>

		
		<dependency>
		    <groupId>org.mockito</groupId>
		    <artifactId>mockito-junit-jupiter</artifactId>
		    <version>5.4.0</version>
		    <scope>test</scope>
		</dependency>
		<dependency>
		    <groupId>org.springframework.security</groupId>
		    <artifactId>spring-security-test</artifactId>
		    <scope>test</scope>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.springdoc/springdoc-openapi-starter-webmvc-ui -->
		<dependency>
		    <groupId>org.springdoc</groupId>
		    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
		    <version>2.6.0</version>
		</dependency>



		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-mongodb</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt -->
	<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-api</artifactId>
			<version>0.11.5</version>
		</dependency>

		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-impl</artifactId>
			<version>0.11.5</version>
			<scope>runtime</scope>
		</dependency>

		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-jackson</artifactId>
			<version>0.11.5</version>
			<scope>runtime</scope>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>io.projectreactor</groupId>
			<artifactId>reactor-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>
